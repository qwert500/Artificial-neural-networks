%% Task 2
clc, clear all
% Starts by a binary representation of 0s and 1s which becomes -1s and 1s
storedPattern(:,1)=([0 0 0 0 0 0 0 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 1 1 1 1 1 1 0 0 ...
  0 1 1 1 0 0 1 1 1 0 ...
  0 1 1 1 0 0 1 1 1 0 ...
  0 1 1 1 0 0 1 1 1 0 ...
  0 1 1 1 0 0 1 1 1 0 ...
  0 1 1 1 0 0 1 1 1 0 ...
  0 1 1 1 0 0 1 1 1 0 ...
  0 1 1 1 0 0 1 1 1 0 ...
  0 1 1 1 0 0 1 1 1 0 ...
  0 1 1 1 0 0 1 1 1 0 ...
  0 1 1 1 0 0 1 1 1 0 ...
  0 0 1 1 1 1 1 1 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 0 0 0 0 0 0 0]+1)*2-3;

storedPattern(:,2)=([0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0 ...
  0 0 0 1 1 1 1 0 0 0]+1)*2-3;

storedPattern(:,3)=([1 1 1 1 1 1 1 1 0 0 ...
  1 1 1 1 1 1 1 1 0 0 ...
  0 0 0 0 0 1 1 1 0 0 ...
  0 0 0 0 0 1 1 1 0 0 ...
  0 0 0 0 0 1 1 1 0 0 ...
  0 0 0 0 0 1 1 1 0 0 ...
  0 0 0 0 0 1 1 1 0 0 ...
  1 1 1 1 1 1 1 1 0 0 ...
  1 1 1 1 1 1 1 1 0 0 ...
  1 1 1 0 0 0 0 0 0 0 ...
  1 1 1 0 0 0 0 0 0 0 ...
  1 1 1 0 0 0 0 0 0 0 ...
  1 1 1 0 0 0 0 0 0 0 ...
  1 1 1 0 0 0 0 0 0 0 ...
  1 1 1 1 1 1 1 1 0 0 ...
  1 1 1 1 1 1 1 1 0 0]+1)*2-3;

storedPattern(:,4)=([0 0 1 1 1 1 1 1 0 0 ...
  0 0 1 1 1 1 1 1 1 0 ...
  0 0 0 0 0 0 1 1 1 0 ...
  0 0 0 0 0 0 1 1 1 0 ...
  0 0 0 0 0 0 1 1 1 0 ...
  0 0 0 0 0 0 1 1 1 0 ...
  0 0 0 0 0 0 1 1 1 0 ...
  0 0 0 0 1 1 1 1 0 0 ...
  0 0 0 0 1 1 1 1 0 0 ...
  0 0 0 0 0 0 1 1 1 0 ...
  0 0 0 0 0 0 1 1 1 0 ...
  0 0 0 0 0 0 1 1 1 0 ...
  0 0 0 0 0 0 1 1 1 0 ...
  0 0 0 0 0 0 1 1 1 0 ...
  0 0 1 1 1 1 1 1 1 0 ...
  0 0 1 1 1 1 1 1 0 0]+1)*2-3;

storedPattern(:,5)=([0 1 1 0 0 0 0 1 1 0 ...
  0 1 1 0 0 0 0 1 1 0 ...
  0 1 1 0 0 0 0 1 1 0 ...
  0 1 1 0 0 0 0 1 1 0 ...
  0 1 1 0 0 0 0 1 1 0 ...
  0 1 1 0 0 0 0 1 1 0 ...
  0 1 1 0 0 0 0 1 1 0 ...
  0 1 1 1 1 1 1 1 1 0 ...
  0 1 1 1 1 1 1 1 1 0 ...
  0 0 0 0 0 0 0 1 1 0 ...
  0 0 0 0 0 0 0 1 1 0 ...
  0 0 0 0 0 0 0 1 1 0 ...
  0 0 0 0 0 0 0 1 1 0 ...
  0 0 0 0 0 0 0 1 1 0 ...
  0 0 0 0 0 0 0 1 1 0 ...
  0 0 0 0 0 0 0 1 1 0 ...
  ]+1)*2-3;

N=160; % Number of bits
p=5; % Stored Patterns
totalNumberOfBlurredBits=N;
w=zeros(N,N); % following loop generates w(i,j)
T=800; %steps
ny=randi(p); % The stored pattern that is to be blurred
S=zeros(N,T+1,totalNumberOfBlurredBits);
Perror=zeros(totalNumberOfBlurredBits,1);

for i=1:N %calculating weights according to Hebb's Rule
  for j=1:N
    if i==j
      w(i,j)=0;
    else
      for k=1:p
        w(i,j)=1/N*storedPattern(i,k)*storedPattern(j,k)+w(i,j);
      end
    end
  end
end

for q=1:totalNumberOfBlurredBits
  randomNumber=zeros(q,1);
  for i=1:q % The element that is to be flipped
    randomNumber(i)=randi(N); 
  end
  blurredPattern=storedPattern(:,ny); % Pattern that is to be flipped
  for j=1:length(randomNumber)
    blurredPattern(randomNumber(j))=storedPattern(randomNumber(j),ny)*(-1); %flipps bits => blurred pattern
  end
  S(:,1,q)=blurredPattern(:);
  
  for t=1:T   %asynchronos update from 1 step to T steps
    i=randi(N);
    wS=0;
    for j=1:N
      wS=w(i,j)*S(j,t,q)+wS; %Hebbes rule
    end
    S(:,t+1,q)=S(:,t,q); %Must have information from last time step
    S(i,t+1,q)=sign(wS); %updates bit
  end
  Perror(q)=(sum((abs(S(:,T+1,q)-storedPattern(:,ny)))/2))/N;
end

q=(1:totalNumberOfBlurredBits)/N;
hold on
title('Correct pattern probability over fracion q=p/N')
xlabel('q')
ylabel('P(correct pattern)')
plot(q,1-Perror)
%% Task 2 extra, bits reprecented as images
j=0;
for t=1:50:T+1
  j=1+j;
  subplot(3,6,j)
  [mat,padded] = vec2mat(S(:,t,40),10);
  image(mat*60)
end